/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-fn",
factory: function (require) {
var plugin=(()=>{var D=Object.create,c=Object.defineProperty,N=Object.defineProperties,E=Object.getOwnPropertyDescriptor,A=Object.getOwnPropertyDescriptors,C=Object.getOwnPropertyNames,g=Object.getOwnPropertySymbols,T=Object.getPrototypeOf,O=Object.prototype.hasOwnProperty,_=Object.prototype.propertyIsEnumerable;var F=(o,e,t)=>e in o?c(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,L=(o,e)=>{for(var t in e||(e={}))O.call(e,t)&&F(o,t,e[t]);if(g)for(var t of g(e))_.call(e,t)&&F(o,t,e[t]);return o},R=(o,e)=>N(o,A(e)),x=o=>c(o,"__esModule",{value:!0});var p=o=>{if(typeof require!="undefined")return require(o);throw new Error('Dynamic require of "'+o+'" is not supported')};var S=(o,e)=>{for(var t in e)c(o,t,{get:e[t],enumerable:!0})},$=(o,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of C(e))!O.call(o,r)&&r!=="default"&&c(o,r,{get:()=>e[r],enumerable:!(t=E(e,r))||t.enumerable});return o},l=o=>$(x(c(o!=null?D(T(o)):{},"default",o&&o.__esModule&&"default"in o?{get:()=>o.default,enumerable:!0}:{value:o,enumerable:!0})),o);var v=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)};var h=(o,e,t)=>(v(o,e,"read from private field"),t?t.call(o):e.get(o)),y=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},k=(o,e,t,r)=>(v(o,e,"write to private field"),r?r.call(o,t):e.set(o,t),t);var U={};S(U,{default:()=>K});var P=l(p("@yarnpkg/core")),f=l(p("@yarnpkg/fslib")),w=l(p("fs"));var i="fn:",u="FN_YARN_LOCK_FILENAME";var a,d=class{constructor(){y(this,a,void 0);let e=process.env[u];if(!e)throw new Error(`Lock file can't be found: ${u} is not set.`);let t="{}";try{t=(0,w.readFileSync)(e,"utf8")}catch(s){}let r=JSON.parse(t);k(this,a,r.modules||{})}supports(e,t){return e.reference.startsWith(i)}getLocalPath(e,t){let{selector:r}=P.structUtils.parseRange(e.reference);if(!r)throw new Error(`locator.reference can't be parsed: ${e.reference}`);for(let[s,M]of Object.entries(h(this,a)))if(r==s)return M.path;throw new Error(`Package "${r}" couldn't be resolved. Known modules:
${JSON.stringify(h(this,a),void 0,2)}`)}async fetch(e,t){let r=this.getLocalPath(e,t);return{packageFs:new f.CwdFS(r),prefixPath:f.PortablePath.dot,localPath:r}}};a=new WeakMap;var n=l(p("@yarnpkg/core")),b=l(p("@yarnpkg/fslib"));var m=class{supportsDescriptor(e,t){return e.range.startsWith(i)}supportsLocator(e,t){return e.reference.startsWith(i)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,r){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,r){let s=e.range.slice(i.length);return[n.structUtils.makeLocator(e,`${i}${b.npath.toPortablePath(s)}`)]}async getSatisfying(e,t,r){return null}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let r=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),s=await n.miscUtils.releaseAfterUseAsync(async()=>await n.Manifest.find(r.prefixPath,{baseFs:r.packageFs}),r.releaseFs);return R(L({},e),{version:s.version||"0.0.0",languageName:s.languageName||t.project.configuration.get("defaultLanguageName"),linkType:n.LinkType.SOFT,conditions:s.getConditions(),dependencies:s.dependencies,peerDependencies:s.peerDependencies,dependenciesMeta:s.dependenciesMeta,peerDependenciesMeta:s.peerDependenciesMeta,bin:s.bin})}};var I={hooks:{afterAllInstalled:()=>{console.log("Foundation plugin installed")}},fetchers:[d],resolvers:[m]},K=I;return U;})();
return plugin;
}
};
