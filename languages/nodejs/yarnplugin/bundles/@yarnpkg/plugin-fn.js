/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-fn",
factory: function (require) {
var plugin=(()=>{var T=Object.create,p=Object.defineProperty,x=Object.defineProperties,E=Object.getOwnPropertyDescriptor,N=Object.getOwnPropertyDescriptors,j=Object.getOwnPropertyNames,y=Object.getOwnPropertySymbols,S=Object.getPrototypeOf,R=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable;var b=(r,e,t)=>e in r?p(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,h=(r,e)=>{for(var t in e||(e={}))R.call(e,t)&&b(r,t,e[t]);if(y)for(var t of y(e))U.call(e,t)&&b(r,t,e[t]);return r},F=(r,e)=>x(r,N(e)),$=r=>p(r,"__esModule",{value:!0});var i=r=>{if(typeof require!="undefined")return require(r);throw new Error('Dynamic require of "'+r+'" is not supported')};var I=(r,e)=>{for(var t in e)p(r,t,{get:e[t],enumerable:!0})},_=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of j(e))!R.call(r,o)&&o!=="default"&&p(r,o,{get:()=>e[o],enumerable:!(t=E(e,o))||t.enumerable});return r},a=r=>_($(p(r!=null?T(S(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var w=(r,e,t)=>{if(!e.has(r))throw TypeError("Cannot "+t)};var O=(r,e,t)=>(w(r,e,"read from private field"),t?t.call(r):e.get(r)),C=(r,e,t)=>{if(e.has(r))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(r):e.set(r,t)},D=(r,e,t,o)=>(w(r,e,"write to private field"),o?o.call(r,t):e.set(r,t),t);var K={};I(K,{default:()=>B});var m=a(i("@yarnpkg/core")),d=a(i("@yarnpkg/fslib")),H=a(i("fs")),A=a(i("path"));var f="fn:",M="node_modules/fn.lock.json";var c,k=class{constructor(){C(this,c,void 0);let e=(0,H.readFileSync)(M,"utf8"),t=JSON.parse(e);D(this,c,t.modules||{})}supports(e,t){return e.reference.startsWith(f)}getLocalPath(e,t){let{selector:o}=m.structUtils.parseRange(e.reference);if(!o)throw new Error(`locator.reference can't be parsed: ${e.reference}`);for(let[s,u]of Object.entries(O(this,c)))if(o.startsWith(s)){let l=o.substring(s.length);return A.default.join(u.path,l)}throw new Error(`Package "${o}" couldn't be resolved. Known modules:
${JSON.stringify(O(this,c),void 0,2)}`)}async fetch(e,t){let o=t.checksums.get(e.locatorHash)||null,[s,u,l]=await t.cache.fetchPackageFromCache(e,o,h({onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,`${m.structUtils.prettyLocator(t.project.configuration,e)} can't be found in the cache and will be fetched from the disk`),loader:()=>this.fetchFromDisk(e,t),skipIntegrityCheck:t.skipIntegrityCheck},t.cacheOptions));return{packageFs:s,releaseFs:u,prefixPath:"",localPath:this.getLocalPath(e,t),checksum:l}}async fetchFromDisk(e,t){return m.tgzUtils.makeArchiveFromDirectory(this.getLocalPath(e,t),{baseFs:new d.CwdFS(d.PortablePath.root),compressionLevel:t.project.configuration.get("compressionLevel")})}};c=new WeakMap;var n=a(i("@yarnpkg/core")),g=a(i("@yarnpkg/fslib"));var z=2,L=class{supportsDescriptor(e,t){return e.range.startsWith(f)}supportsLocator(e,t){return e.reference.startsWith(f)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,o){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,o){if(!o.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let s=n.structUtils.makeLocator(e,e.range),l=(await n.tgzUtils.makeArchiveFromDirectory(o.fetchOptions.fetcher.getLocalPath(s,o.fetchOptions),{baseFs:new g.CwdFS(g.PortablePath.root),compressionLevel:o.fetchOptions.project.configuration.get("compressionLevel"),inMemory:!0})).getBufferAndClose(),v=n.hashUtils.makeHash(`${z}`,l).slice(0,6),P=`${s.reference}::${v}`;return[F(h({},s),{locatorHash:n.hashUtils.makeHash(s.identHash,P),reference:P})]}async getSatisfying(e,t,o){return null}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let o=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),s=await n.miscUtils.releaseAfterUseAsync(async()=>await n.Manifest.find(o.prefixPath,{baseFs:o.packageFs}),o.releaseFs);return F(h({},e),{version:s.version||"0.0.0",languageName:s.languageName||t.project.configuration.get("defaultLanguageName"),linkType:n.LinkType.HARD,conditions:s.getConditions(),dependencies:s.dependencies,peerDependencies:s.peerDependencies,dependenciesMeta:s.dependenciesMeta,peerDependenciesMeta:s.peerDependenciesMeta,bin:s.bin})}};var W={hooks:{afterAllInstalled:()=>{console.log("Foundation plugin installed")}},fetchers:[k],resolvers:[L]},B=W;return K;})();
return plugin;
}
};
