/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-fn",
factory: function (require) {
var plugin=(()=>{var C=Object.create,l=Object.defineProperty,x=Object.defineProperties,A=Object.getOwnPropertyDescriptor,N=Object.getOwnPropertyDescriptors,S=Object.getOwnPropertyNames,u=Object.getOwnPropertySymbols,E=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty,_=Object.prototype.propertyIsEnumerable;var O=(t,e,o)=>e in t?l(t,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[e]=o,F=(t,e)=>{for(var o in e||(e={}))g.call(e,o)&&O(t,o,e[o]);if(u)for(var o of u(e))_.call(e,o)&&O(t,o,e[o]);return t},L=(t,e)=>x(t,N(e)),$=t=>l(t,"__esModule",{value:!0});var a=t=>{if(typeof require!="undefined")return require(t);throw new Error('Dynamic require of "'+t+'" is not supported')};var j=(t,e)=>{for(var o in e)l(t,o,{get:e[o],enumerable:!0})},U=(t,e,o)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of S(e))!g.call(t,r)&&r!=="default"&&l(t,r,{get:()=>e[r],enumerable:!(o=A(e,r))||o.enumerable});return t},c=t=>U($(l(t!=null?C(E(t)):{},"default",t&&t.__esModule&&"default"in t?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var P=(t,e,o)=>{if(!e.has(t))throw TypeError("Cannot "+o)};var h=(t,e,o)=>(P(t,e,"read from private field"),o?o.call(t):e.get(t)),v=(t,e,o)=>{if(e.has(t))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(t):e.set(t,o)},y=(t,e,o,r)=>(P(t,e,"write to private field"),r?r.call(t,o):e.set(t,o),o);var K={};j(K,{default:()=>I});var k=c(a("@yarnpkg/core")),f=c(a("@yarnpkg/fslib")),b=c(a("fs")),w=c(a("path"));var i="fn:",R="node_modules/fn.lock.json";var p,d=class{constructor(){v(this,p,void 0);let e=(0,b.readFileSync)(R,"utf8"),o=JSON.parse(e);y(this,p,o.modules||{})}supports(e,o){return e.reference.startsWith(i)}getLocalPath(e,o){let{selector:r}=k.structUtils.parseRange(e.reference);if(!r)throw new Error(`locator.reference can't be parsed: ${e.reference}`);for(let[s,M]of Object.entries(h(this,p)))if(r.startsWith(s)){let T=r.substring(s.length);return w.default.join(M.path,T)}throw new Error(`Package "${r}" couldn't be resolved. Known modules:
${JSON.stringify(h(this,p),void 0,2)}`)}async fetch(e,o){let r=this.getLocalPath(e,o);return{packageFs:new f.CwdFS(r),prefixPath:f.PortablePath.dot,localPath:r}}};p=new WeakMap;var n=c(a("@yarnpkg/core")),D=c(a("@yarnpkg/fslib"));var m=class{supportsDescriptor(e,o){return e.range.startsWith(i)}supportsLocator(e,o){return e.reference.startsWith(i)}shouldPersistResolution(e,o){return!1}bindDescriptor(e,o,r){return e}getResolutionDependencies(e,o){return[]}async getCandidates(e,o,r){let s=e.range.slice(i.length);return[n.structUtils.makeLocator(e,`${i}${D.npath.toPortablePath(s)}`)]}async getSatisfying(e,o,r){return null}async resolve(e,o){if(!o.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let r=await o.fetchOptions.fetcher.fetch(e,o.fetchOptions),s=await n.miscUtils.releaseAfterUseAsync(async()=>await n.Manifest.find(r.prefixPath,{baseFs:r.packageFs}),r.releaseFs);return L(F({},e),{version:s.version||"0.0.0",languageName:s.languageName||o.project.configuration.get("defaultLanguageName"),linkType:n.LinkType.SOFT,conditions:s.getConditions(),dependencies:s.dependencies,peerDependencies:s.peerDependencies,dependenciesMeta:s.dependenciesMeta,peerDependenciesMeta:s.peerDependenciesMeta,bin:s.bin})}};var W={hooks:{afterAllInstalled:()=>{console.log("Foundation plugin installed")}},fetchers:[d],resolvers:[m]},I=W;return K;})();
return plugin;
}
};
