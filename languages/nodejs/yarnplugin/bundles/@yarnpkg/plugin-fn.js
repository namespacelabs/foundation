/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-fn",
factory: function (require) {
var plugin=(()=>{var E=Object.create,l=Object.defineProperty,A=Object.defineProperties,C=Object.getOwnPropertyDescriptor,T=Object.getOwnPropertyDescriptors,_=Object.getOwnPropertyNames,g=Object.getOwnPropertySymbols,x=Object.getPrototypeOf,O=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable;var F=(o,e,t)=>e in o?l(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,L=(o,e)=>{for(var t in e||(e={}))O.call(e,t)&&F(o,t,e[t]);if(g)for(var t of g(e))S.call(e,t)&&F(o,t,e[t]);return o},v=(o,e)=>A(o,T(e)),$=o=>l(o,"__esModule",{value:!0});var a=o=>{if(typeof require!="undefined")return require(o);throw new Error('Dynamic require of "'+o+'" is not supported')};var I=(o,e)=>{for(var t in e)l(o,t,{get:e[t],enumerable:!0})},K=(o,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of _(e))!O.call(o,r)&&r!=="default"&&l(o,r,{get:()=>e[r],enumerable:!(t=C(e,r))||t.enumerable});return o},c=o=>K($(l(o!=null?E(x(o)):{},"default",o&&o.__esModule&&"default"in o?{get:()=>o.default,enumerable:!0}:{value:o,enumerable:!0})),o);var P=(o,e,t)=>{if(!e.has(o))throw TypeError("Cannot "+t)};var h=(o,e,t)=>(P(o,e,"read from private field"),t?t.call(o):e.get(o)),y=(o,e,t)=>{if(e.has(o))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(o):e.set(o,t)},R=(o,e,t,r)=>(P(o,e,"write to private field"),r?r.call(o,t):e.set(o,t),t);var j={};I(j,{default:()=>W});var k=c(a("@yarnpkg/core")),f=c(a("@yarnpkg/fslib")),b=c(a("fs")),w=c(a("path"));var i="fn:",d="FN_YARN_LOCK_FILENAME";var p,m=class{constructor(){y(this,p,void 0);let e=process.env[d];if(!e)throw new Error(`Lock file can't be found: ${d} is not set.`);let t="{}";try{t=(0,b.readFileSync)(e,"utf8")}catch(s){}let r=JSON.parse(t);R(this,p,r.modules||{})}supports(e,t){return e.reference.startsWith(i)}getLocalPath(e,t){let{selector:r}=k.structUtils.parseRange(e.reference);if(!r)throw new Error(`locator.reference can't be parsed: ${e.reference}`);for(let[s,D]of Object.entries(h(this,p)))if(r.startsWith(s)){let N=r.substring(s.length);return w.default.join(D.path,N)}throw new Error(`Package "${r}" couldn't be resolved. Known modules:
${JSON.stringify(h(this,p),void 0,2)}`)}async fetch(e,t){let r=this.getLocalPath(e,t);return{packageFs:new f.CwdFS(r),prefixPath:f.PortablePath.dot,localPath:r}}};p=new WeakMap;var n=c(a("@yarnpkg/core")),M=c(a("@yarnpkg/fslib"));var u=class{supportsDescriptor(e,t){return e.range.startsWith(i)}supportsLocator(e,t){return e.reference.startsWith(i)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,r){return e}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,r){let s=e.range.slice(i.length);return[n.structUtils.makeLocator(e,`${i}${M.npath.toPortablePath(s)}`)]}async getSatisfying(e,t,r){return null}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let r=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),s=await n.miscUtils.releaseAfterUseAsync(async()=>await n.Manifest.find(r.prefixPath,{baseFs:r.packageFs}),r.releaseFs);return v(L({},e),{version:s.version||"0.0.0",languageName:s.languageName||t.project.configuration.get("defaultLanguageName"),linkType:n.LinkType.SOFT,conditions:s.getConditions(),dependencies:s.dependencies,peerDependencies:s.peerDependencies,dependenciesMeta:s.dependenciesMeta,peerDependenciesMeta:s.peerDependenciesMeta,bin:s.bin})}};var U={hooks:{afterAllInstalled:()=>{console.log("Foundation plugin installed")}},fetchers:[m],resolvers:[u]},W=U;return j;})();
return plugin;
}
};
