// Copyright 2022 Namespace Labs Inc; All rights reserved.
// Licensed under the EARLY ACCESS SOFTWARE LICENSE AGREEMENT
// available at http://github.com/namespacelabs/foundation

syntax = "proto3";

package foundation.runtime.kubernetes.kubedef;

option go_package = "namespacelabs.dev/foundation/runtime/kubernetes/kubedef";

import "std/types/invocation.proto";

message SpecExtension {
    // XXX ideally we'd use Kubernetes protos here.
    string              service_account = 3;
    repeated Volume     volume          = 1;
    repeated Annotation annotation      = 2;

    message Volume {
        string name = 1;

        oneof volume_type {
            Secret    secret     = 2;
            ConfigMap config_map = 3;
        }

        message Secret {
            string secret_name = 1;
        }

        message ConfigMap {
            string        name            = 1;
            string        config_map_name = 2;
            repeated Item item            = 3;

            message Item {
                string key  = 1;
                string path = 2;
            }
        }
    }

    message Annotation {
        string key   = 1;
        string value = 2;
    }
}

message ContainerExtension {
    repeated VolumeMount volume_mount = 1;
    repeated Env         env          = 2;
    repeated string      args         = 5;

    // Deprecated, use `args`.
    repeated ArgTuple arg_tuple = 4;
    // Deprecated, use `InitContainerExtension`.
    repeated InitContainer init_container = 3;

    message VolumeMount {
        string name          = 1;
        bool   read_only     = 2;
        string mount_path    = 3;
        bool   mount_on_init = 4;  // Whether to mount this volume also for init containers.
    }

    message Env {
        string name  = 1;
        string value = 2;
    }

    message ArgTuple {
        string name  = 1;
        string value = 2;
    }

    message InitContainer {
        string          package_name = 1;
        repeated string arg          = 2;
    }
}

message InitContainerExtension {
    string package_name = 1;

    repeated string args = 2;
}

message OpApply {
    string resource  = 1;
    string namespace = 2;
    string name      = 3;
    string body_json = 4;
}

message OpDelete {
    string resource  = 1;
    string namespace = 2;
    string name      = 3;
}

message OpDeleteList {
    string resource       = 1;
    string namespace      = 2;
    string label_selector = 3;
}

message OpCreate {
    string resource   = 1;
    bool   if_missing = 2;
    string namespace  = 3;
    string name       = 4;
    string body_json  = 5;
}

// This is a temporary type; usage should be limited. It's a workaround until we
// can compose invocations, so secrets can wrap a "create secret payload" invocation
// around the user-provided invocation.
message OpCreateSecretConditionally {
    string namespace                                 = 1;
    string                       name                = 2;
    string                       user_specified_name = 3;
    std.types.DeferredInvocation invocation          = 4;
}